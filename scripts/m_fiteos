#!/usr/bin/env python3
"""Auto non-linear fitting of Equation of State.

Four argument is needed: data file, number of formula units, E0 and V0.

The data file should have volume and energy data columns.
The default indices of volume and energy columns are 1 and 2, respectively (starting from 1).
They can be specified by option ``--vc`` and ``--ec``.

For now, eV and Angstrom^3 are assumed as units.

The last two can be extracted by figuring out the lowest point among the data, if not specified.
"""
import sys
from argparse import ArgumentParser, RawDescriptionHelpFormatter
import numpy as np
from scipy.optimize import curve_fit

from mushroom.core.eos import get_eos, available_eos
from mushroom.core.constants import EV_PER_ANG_CUB2GPA

def _parser():
    """the parser"""
    p = ArgumentParser(description=__doc__, formatter_class=RawDescriptionHelpFormatter)
    p.add_argument("input", type=str, help="input data file")
    p.add_argument("-n", type=int,
                   help="number of formula units")
    p.add_argument("-v", dest="v0", type=float,
                   help="initial guess of ground state volume V0")
    p.add_argument("-e", dest="e0", type=float,
                   help="initial guess of ground state energy E0")
    #p.add_argument("-f", help="fixed B' when fitting (still bug)", type=float)
    #p.add_argument("-p", action="store_true", help="flag for plotting")
    p.add_argument("--eos", dest="eosname", type=str,
                   choices=available_eos, default="bm",
                   help="type of EOS, default using Birch-Murnaghan (bm)")
    p.add_argument("--vc", dest="ivcol", type=int, default=1, \
                   help="column index of volume data. Default 1")
    p.add_argument("--ec", dest="iecol", type=int, default=2, \
                   help="column index of energy data. Default 2")
    return p

# pylint: disable=R0914
def _export_fitted(popt, pcov, vols, vfit, enes, efit,
                   eosname, output):
    """export fitted data, shift energy zero to E0"""
    eosfunc, shortname, _ = get_eos(eosname)
    perr = np.sqrt(np.diag(pcov))
    conv = EV_PER_ANG_CUB2GPA
    print("Fitting {} EOS".format(shortname))
    print("  E0 = {:13.5f} ({:9.5f})".format(popt[0], perr[0]))
    print("  V0 = {:13.5f} ({:9.4f})".format(popt[1], perr[1]))
    # modulus, converting eV/A^3 to GPa needs a factor of ~160
    print("  B0 = {:13.3f} ({:9.3f})".format(popt[2]*conv, perr[2]*conv))
    if len(popt) > 3:
        print("  Bp = ", popt[3])

    efit -= popt[0]
    enes -= popt[0]

    R2 = 1 - np.sum((enes-eosfunc(vols, *popt))**2) \
             / np.sum((enes-np.mean(enes))**2)

    with open(output, 'w') as h:
        p = lambda x: print(x, file=h)
        p("#Data generated by: {}".format(" ".join(sys.argv)))
        p("#Fitted {} EOS data, shifted zero to E0".format(eosname))
        p("#E0(eV) {} stderr {}".format(popt[0], perr[0]))
        p("#V0(A3) {} stderr {}".format(popt[1], perr[1]))
        p("#B0(eV/A3) {} stderr {}".format(popt[2], perr[2]))
        p("#B0(GPa) {} stderr {}".format(popt[2]*conv, perr[2]*conv))
        p("#other parameters: {} stderr {}".format(popt[3:], perr[3:]))
        p("#R2: {}".format(R2))
        for v, e in zip(vfit, efit):
            p("{:15.6f} {:15.6f}".format(v, e))
        p("")
        p("#Shifted original data")
        for v, e in zip(vols, enes):
            p("{:15.6f} {:15.6f}".format(v, e))

# pylint: disable=W0632
def m_fiteos():
    """the main stream"""
    args = _parser().parse_args()

    # initialization
    b0 = 1.0
    bp = 4.0
    nfu = 1
    if args.n is not None:
        nfu = args.n
    vols, enes = np.loadtxt(args.input, unpack=True,
                            usecols=(args.ivcol-1, args.iecol-1))

    if nfu != 1:
        vols /= nfu
        enes /= nfu

    e0 = min(enes)
    if args.e0 is not None:
        e0 = args.e0
    v0 = vols[np.where(enes == e0)][0]
    if args.v0 is not None:
        v0 = args.v0

    eosfunc, _, nparams = get_eos(args.eosname)
    opts_curve_fit = {"maxfev": 5000}

    #if not args.f:
    #    bp = 4.0
    #    popt, pcov = curve_fit(eosfunc, vols, enes, p0=[e0, v0, b0, bp])
    #    bp = popt[3]
    #else:
    #    bp = args.f
    #    popt, pcov = curve_fit(lambda _v, _e0, _v0, _b0: eosfunc(_v, _e0, _v0, _b0, bp), \
    #                           vols, enes, p0=[e0, v0, b0])
    popt, pcov = curve_fit(eosfunc, vols, enes, p0=[e0, v0, b0, bp],
                           **opts_curve_fit)

    # write fitted data
    vfit = np.linspace(0.98*min(vols), 1.02*max(vols), 100)
    efit = eosfunc(vfit, *popt)

    _export_fitted(popt, pcov, vols, vfit, enes, efit,
                   eosname=args.eosname, output=args.input+"_fitted")

    ## plotting to see if it works
    #if args.p:
    #    import pylab
    #    pylab.text(0.1, 0.9, 'matplotlib')
    #    pylab.xlabel("Volume, $\AA^3$")
    #    pylab.ylabel("Energy, eV")
    #    pylab.plot(vols, enes, marker='o', color='red', ls='')
    #    pylab.plot(vfit, efit, color='black')
    #    pylab.show()

if __name__ == "__main__":
    m_fiteos()

